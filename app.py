import streamlit as st

import numpy as np
import json
import random
import string

from transformers import VitsModel, AutoTokenizer
import torch

# setting keys list for input rows management
if 'input_keys' not in st.session_state:
    st.session_state.input_keys = []

# Opening JSON file and loading speakers parameter
with open('speakers.json', 'r') as file:
    speakers = json.load(file)


def get_speaker_name(ind: int):
    key_list = list(speakers.keys())
    val_list = list(speakers.values())
    position = val_list.index(ind)
    return key_list[position]


# Set page title and icon
st.set_page_config(page_title="LiteTTS", page_icon=":speaking_head_in_silhouette:")


# @st.cache_resource
def run_russian_tts(genre, text):
    model = VitsModel.from_pretrained("joefox/tts_vits_ru_hf")
    tokenizer = AutoTokenizer.from_pretrained("joefox/tts_vits_ru_hf")

    text = text.lower()
    inputs = tokenizer(text, return_tensors="pt")
    inputs['speaker_id'] = genre

    with torch.no_grad():
        output = model(**inputs).waveform

    # scipy.io.wavfile.write("techno.wav", rate=model.config.sampling_rate, data=output[0].cpu().numpy())

    # print(type(output[0].cpu().numpy()))

    return output[0].cpu().numpy(), model.config.sampling_rate


def main():
    # Header with image

    # Header
    st.title("Light App for Text-to-Speech")

    # Subtitle
    st.markdown("**This app will help you turn your text into speech using machine learning models**")

    # Some example content
    st.write("""
        Use the button below to add a sentence ! \n
        Select the speaker in the dropdown list and then type your text.\n
        Use the "+" sign to accentuate a sound. Eg.: прив+ет, как дел+а? всё +очень хорош+о! а у тебя как?
    """)

    # Creating tabs for every function
    tab1, tab2 = st.tabs(["Russian TTS", "Credits & Legal"])

    with tab1:

        # When clicked, will create and input key in the session_state variables
        if st.button("Add new sentence", key="add"):
            st.session_state.input_keys.append(random.choice(string.ascii_uppercase) + str(random.randint(0, 999999)))

        input_values = []

        for input_key in st.session_state.input_keys:
            col1, col2 = st.columns([0.2, 0.8])

            with col1:
                # SelectBox to select Speaker voice - will be mapped with speaker configuration to determine integer
                # Receives its key from st.session_state.input_keys with concatenation of BOX + input key
                speaker = st.selectbox(
                    "Speaker",
                    speakers.keys(),
                    key=f"BOX{input_key}",
                    index=None,
                    placeholder="Select voice...",
                    label_visibility='collapsed'
                )

            with col2:
                # Text input for speaker sentence typing - must be in cyrillic alphabet
                # Receives its key from st.session_state.input_keys with input key
                sentence = st.text_input("Please input something",
                                         label_visibility='collapsed',
                                         placeholder="Type sentence...",
                                         key=input_key)

            # Will recreate the iput values list for every input_key generated by "Add new button" - missing speaker
            # id will not be added
            if speaker is not None:
                input_values.append([speakers[speaker], sentence])
                # print(input_values)

        # initialization of audio numpy array that will be used to concatenate sentences from different speakers
        audio_np = np.array([])
        rate = 15000  # sampling rate

        # For every sentence entered by user, generate TTS
        if st.button("Generate", type="primary", key="go"):
            for sentence in input_values:
                st.write(f"{get_speaker_name(sentence[0])}: {sentence[1]}")

                tts = run_russian_tts(sentence[0], sentence[1] + "\n")
                st.audio(data=tts[0], format="audio/wav", start_time=0, sample_rate=rate, end_time=None, loop=False)

                audio_np = np.append(audio_np, tts[0])

            # Generate and output audio file
            st.write("Full dialog:")
            st.audio(data=audio_np, format="audio/wav", start_time=0, sample_rate=rate, end_time=None, loop=False)

    with tab2:
        # Credits
        st.header("Credits")
        st.write(
            """
            - **Model:** This web app utilizes \n
            For **Russian TTS** : the TTS-VITS-RU model by JoeFox, available from Hugging Face's model hub. Visit [here](https://huggingface.co/joefox/tts_vits_ru_hf) for more information.
            - **Hugging Face:** We extend our gratitude to Hugging Face for providing a platform to access and utilize state-of-the-art natural language processing models.
            """
        )

        # Legal Disclaimer
        st.header("Legal Disclaimer")
        st.write(
            """
            - **Model Usage:** The text-to-speech model utilized in this web app is provided by a third party and is intended for demonstration and educational purposes only. It should not be used to generate harmful or misleading content.
            - **Accuracy Disclaimer:** While efforts have been made to ensure the accuracy of the generated speech, we do not guarantee the correctness, completeness, or reliability of the output. Users are advised to verify the accuracy of the generated content before relying on it.
            - **Intellectual Property:** All intellectual property rights pertaining to the model and its outputs belong to their respective owners. This web app does not claim ownership over the model or any content generated by it.
            - **Liability:** We disclaim any liability for damages arising from the use of this web app or reliance on the generated content. Users agree to use the app at their own risk.
            """
        )


if __name__ == "__main__":
    main()
